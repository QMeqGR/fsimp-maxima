/*
;;  Initial code author: David Scherfgen

;;  Author Eric Majzoub, Department of Physics and Astronomy
;;  University of Missouri, St. Louis
;;  Copyright (C) 2024 Eric Majzoub

;;  This program is free software; you can redistribute it and/or modify 
;;  it under the terms of the GNU General Public License as published by         
;;  the Free Software Foundation; either version 2 of the License, or            
;;  (at your option) any later version.                                  
                                                                                 
;;  This program is distributed in the hope that it will be useful,              
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of               
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                
;;  GNU General Public License for more details.         

*/

fsimp_ver:"v0.0.3"$

load("fsimp.lisp")$
load("fsimp-index.lisp")$
load("fsimp-index-html.lisp")$
load("fstrgsimp.mac")$

/*
Adapted from David Scherfgen's dssimp.mac code.

Try a simulated annealing type approach:
smaller --> always take it
bigger --> take it if the change is smaller than say 30% larger

How to order the operations? A before B always, etc...
For example, expand should always be before combine, etc.

*/

fsimp(expr, r) :=
    block([exprSize, smallestExpr, smallestExprSize, simpdExpr,
      simpdExprSize,origExprSize,L,loopmax:2,sizefactor:0.8,
      fpprintprec:5],
      if fsdebug>1 then print("# sizefactor variable: ",sizefactor),
      origExprSize: exprSize : cost(expr),
      if fsdebug=1 then print("original expression size: ",exprSize),
      smallestExpr : expr,
      smallestExprSize : exprSize,

      simpdExpr : expr,
      simpdExprSize : exprSize,
      for L: 1 thru loopmax do
      block(
         if fsdebug>1 and L=1 then print("************* Entering main loop *******************"),
         if fsdebug>1 then print("-------------------------- loopcnt=",L),
         if fsdebug>2 then display(expr),
         if L > loopmax then return(expr),

         block(
            for i : 1 thru length(r) do
            block(
             /* always combine after every simp function */
             simpdExpr : combine( r[i](smallestExpr) ),
             simpdExprSize : cost(simpdExpr),
             if fsdebug>1 then print(r[i],"-- new size -->",simpdExprSize),
             if fsdebug>3 then display(simpdExpr),

             /* if the expression is smaller always take the step */
             if simpdExprSize < exprSize then
             block(
                 smallestExpr : simpdExpr,
                 smallestExprSize : simpdExprSize,
                 if fsdebug>1 then print(">>>>> redefining smallestExpr: ",smallestExprSize),
                 expr : smallestExpr,
                 exprSize : smallestExprSize
             ),
             /* only take slightly larger expressions
                but never return them */
             if simpdExprSize > smallestExprSize then
             block([t1],
               t1: (simpdExprSize - smallestExprSize) / smallestExprSize,
               if fsdebug>1 then print("t1=",float(t1)),
               if t1 < sizefactor then
               block(
                 if fsdebug>1 then print(">>>>>> trying bigger expr"),
                 smallestExpr : simpdExpr,
                 smallestExprSize : simpdExprSize
             ))
         )
       )
     ),
   if fsdebug=1 then print("final expr size: ",cost(expr)),
   return(expr)
);

fsimpall(expr,[remlist]) :=
   if listp (expr) or setp (expr) then
   map(lambda([x],fsimpall(x,[remlist])),expr)
   else if matrixp (expr) then matrixmap(lambda([x],fsimpall(x,[remlist])),expr)
   else block([
   trigfuns:[sin,cos,tan,atan,asin,acos,sec,asec,csc,cot,
             cosh,sinh,acosh,asinh,tanh,atanh,csch,coth],
   trigflag:0,expflag:0,
   triglist:['trigexpand,factor,fstrigsimp,trigsimp,trigreduce,trigrat],
   loglist:[logcontract],
   explist:['demoivre,'exponentialize], /* they are variables too, quote them! */
   simplist:[resimplify, expand, combine, radcan, ratsimp,
            rootscontract, xthru, multthru, factor, sqrtdenest,
            minfactorial] ],

  for i: 1 thru length(trigfuns) do
    if freeof(trigfuns[i],expr)=false then (trigflag:1,expflag:1),
  if freeof(exp,expr)=false then (trigflag:1,expflag:1),
  if freeof(%e,expr)=false then (trigflag:1,expflag:1),
  if trigflag=1 then simplist: append(triglist,simplist),
  if expflag=1 then simplist: append(explist,simplist),
  if freeof(log,expr)=false then simplist:append(loglist,simplist),
  if freeof(gamma,expr)=false then (load("gamma_simp.mac"),
    simplist:append([gamma_simp],simplist)),
  if freeof(factorial,expr)=false then (load("gamma_simp.mac"),
    simplist:append([factorial_simp],simplist)),

  /* user may remove any simplifications by hand */
  if remlist#[] then simplist:fs_exclude(remlist,simplist),
  if fsdebug=1 then display(remlist,simplist),

  /* user may define custom simplifications through
     the variable fs_custom_simp, it should be a list.
     e.g. [lambda([q], block([algebraic : true], ratsimp(q)))]
  */
  if fsdebug=1 then display(fs_custom_simp),
  if properties(fs_custom_simp)#[] then simplist:append(simplist,fs_custom_simp),

  /* call fsimp */
  fsimp(expr, simplist)
  );

alias(fullsimp,fsimpall);
declare(fsimpall,evfun);
declare(fullsimp,evfun);


/*******************************************/
/*         Utility functions               */
/*******************************************/

fssl(expr):=slength(string(expr)); /* string length of expr */
fssize(expr):=conssize(expr)+fssl(expr); /* new cost function */
cost(expr):=fssize(expr)$

/* Remove list1 contents from list2 */
fs_exclude(list1,list2):=block([out:list2],
  if listp(list1)=false or listp(list2)=false then
  return(print("Arguments must be lists.")),
  for i in list1 do out:delete(i,out),
  out
  )$
